## ğŸ“ˆ TEMA 2 â€“ ProgressÃ£o AritmÃ©tica (PA)

A **ProgressÃ£o AritmÃ©tica (PA)** Ã© uma sequÃªncia numÃ©rica onde **cada termo Ã© obtido somando uma constante ao termo anterior**. Essa constante Ã© chamada de **razÃ£o**, representada por $r$.

### âœï¸ Lei de FormaÃ§Ã£o da PA

Seja uma PA $(a_1, a_2, a_3, \dots)$, temos:

$$
a_{n} = a_1 + (n - 1)r
$$

* $a_1$: primeiro termo
* $r$: razÃ£o da PA
* $n$: posiÃ§Ã£o do termo na sequÃªncia

### ğŸ§  Exemplo 1

Seja a PA com $a_1 = 2$ e $r = 3$. EntÃ£o:

$$
a_2 = 2 + 3 = 5 \quad a_3 = 2 + 2\cdot3 = 8 \quad a_4 = 2 + 3\cdot3 = 11
$$

### ğŸ“ Soma dos Termos da PA

A soma dos $n$ primeiros termos de uma PA Ã© dada por:

$$
S_n = \frac{n}{2}(a_1 + a_n)
$$

ou, usando a fÃ³rmula do termo geral:

$$
S_n = \frac{n}{2}\left[2a_1 + (n - 1)r\right]
$$

### ğŸ’¹ Exemplo Financeiro

Um investidor aplica R\$ 100 por mÃªs em uma carteira de crescimento linear. A cada mÃªs ele aumenta o aporte em R\$ 20. O total acumulado em 6 meses serÃ¡:

$$
a_1 = 100, \quad r = 20, \quad n = 6
$$

$$
S_6 = \frac{6}{2}(2\cdot100 + (6-1)\cdot20) = 3(200 + 100) = 3\cdot300 = 900
$$

Ou seja, R\$ 900 no total.

### ğŸ’» Exemplo em C++

```cpp
// FunÃ§Ã£o auxiliar que calcula uma aproximaÃ§Ã£o para o seno de x
// usando a SÃ©rie de Taylor centrada em zero (Maclaurin)
double seno(double x, int termos = 10) {
    double resultado = 0.0;       // Acumulador do valor final da sÃ©rie
    double numerador = x;         // ComeÃ§amos com o primeiro termo: xÂ¹
    double denominador = 1.0;     // Fatorial correspondente: 1!
    int sinal = 1;                // Primeiro termo Ã© positivo

    // Loop que soma os 'termos' da sÃ©rie de Taylor
    for (int i = 0; i < termos; ++i) {
        // Adicionamos o termo atual Ã  soma:
        // resultado += sinal Ã— (xâ¿ / n!)
        resultado += sinal * (numerador / denominador);

        // Preparamos o prÃ³ximo termo:
        // PrÃ³xima potÃªncia: xâ¿ â†’ xâ¿âºÂ²
        // Como jÃ¡ temos xâ¿, basta multiplicar por xÂ²
        numerador *= x * x;

        // PrÃ³ximo fatorial: n! â†’ (n+2)!
        // Atualizamos o denominador multiplicando pelos dois prÃ³ximos inteiros:
        // Exemplo: 3! = 1Ã—2Ã—3 â†’ prÃ³ximo: 5! = 1Ã—2Ã—3Ã—4Ã—5 â†’ multiplica por 4 e 5
        denominador *= (2 * i + 2) * (2 * i + 3);

        // Alternamos o sinal: + â†’ - â†’ + â†’ ...
        sinal = -sinal;
    }

    // Ao final das iteraÃ§Ãµes, retornamos a soma dos termos
    return resultado;
}

// FunÃ§Ã£o auxiliar que calcula uma aproximaÃ§Ã£o para o cosseno de x
// usando a SÃ©rie de Taylor centrada em zero (Maclaurin)
double cosseno(double x, int termos = 10) {
    double resultado = 0.0;       // Acumulador do valor final da sÃ©rie
    double numerador = 1.0;       // Primeiro termo: xâ° = 1
    double denominador = 1.0;     // Fatorial correspondente: 0! = 1
    int sinal = 1;                // Primeiro termo Ã© positivo

    // Loop que soma os 'termos' da sÃ©rie de Taylor
    for (int i = 0; i < termos; ++i) {
        // Adicionamos o termo atual Ã  soma:
        // resultado += sinal Ã— (xâ¿ / n!)
        resultado += sinal * (numerador / denominador);

        // Preparamos o prÃ³ximo termo da sÃ©rie:
        // PrÃ³xima potÃªncia par: xâ¿ â†’ xâ¿âºÂ² (multiplica por xÂ²)
        numerador *= x * x;

        // PrÃ³ximo fatorial: n! â†’ (n+2)! (multiplica pelos dois prÃ³ximos inteiros)
        // Exemplo: 2! = 1Ã—2 â†’ 4! = 1Ã—2Ã—3Ã—4 â†’ multiplica por 3 e 4
        denominador *= (2 * i + 1) * (2 * i + 2);

        // Alternamos o sinal: + â†’ - â†’ + â†’ ...
        sinal = -sinal;
    }

    // Ao final das iteraÃ§Ãµes, retornamos a soma dos termos
    return resultado;
}

// Gera pontos da circunferÃªncia centrada em (x0, y0) de raio r, variando o parÃ¢metro t
void gerarCircunferenciaParametrica(double x0, double y0, double r) {
    for (double t = 0.0; t <= 2 * PI; t += 0.1) {
        double x = x0 + r * cosseno(t);
        double y = y0 + r * seno(t);
        cout << "Ponto: (" << x << ", " << y << ")" << endl;
    }
}
```

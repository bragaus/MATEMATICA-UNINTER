# ğŸŒ€ TEMA 3 â€“ CircunferÃªncia no Plano

A circunferÃªncia Ã© uma figura fundamental da geometria analÃ­tica, representando todos os pontos equidistantes de um ponto fixo â€” o centro.

---

## ğŸ“ EquaÃ§Ã£o da CircunferÃªncia

### EquaÃ§Ã£o padrÃ£o:

$$
(x - a)^2 + (y - b)^2 = R^2
$$

* $(a, b)$: coordenadas do centro
* $R$: raio da circunferÃªncia

> ğŸ’­ *Analogia PsicodÃ©lica*: A circunferÃªncia Ã© o pulso do espaÃ§o. Ela gira em torno de si mesma como o tempo em torno da consciÃªncia.

---

## ğŸ§  InterpretaÃ§Ã£o GeomÃ©trica

* Todos os pontos $P(x, y)$ que satisfazem a equaÃ§Ã£o estÃ£o a uma distÃ¢ncia $R$ do centro $(a, b)$
* A forma geral da equaÃ§Ã£o revela simetria perfeita em relaÃ§Ã£o ao centro

---

## ğŸ“ˆ Exemplo em C++

```cpp
// Calcula o valor absoluto (mÃ³dulo) de um nÃºmero real
// FÃ³rmula: |x| = x, se x â‰¥ 0; caso contrÃ¡rio, |x| = âˆ’x
float calcularValorAbsoluto(float numero) {
    return (numero >= 0) ? numero : -numero;
}

// Aproxima a raiz quadrada de um nÃºmero real nÃ£o-negativo
// Utiliza o mÃ©todo de Newton-Raphson para convergÃªncia
// FÃ³rmula: âˆšS â‰ˆ xâ‚™, com xâ‚™â‚Šâ‚ = Â½(xâ‚™ + Sâ„xâ‚™)
float calcularRaizQuadrada(float numeroOriginal) {
    if (numeroOriginal < 0) return -1; // Raiz de nÃºmero negativo nÃ£o Ã© real (neste contexto)
    if (numeroOriginal == 0) return 0;

    float estimativaAtual = numeroOriginal / 2.0f;

    // Ajuste para valores muito pequenos
    if (estimativaAtual < 1.0f) estimativaAtual = 1.0f;

    // Refinamento da estimativa via Newton-Raphson
    for (int iteracao = 0; iteracao < 20; ++iteracao) {
        estimativaAtual = 0.5f * (estimativaAtual + numeroOriginal / estimativaAtual);
    }

    return estimativaAtual;
}

// Verifica se um ponto estÃ¡ sobre a circunferÃªncia de centro (centroX, centroY) e raio
// FÃ³rmula da circunferÃªncia: (x âˆ’ centroX)Â² + (y âˆ’ centroY)Â² = raioÂ²
bool pontoEstaSobreCircunferencia(
    float coordenadaXDoPonto,
    float coordenadaYDoPonto,
    float coordenadaXDoCentro,
    float coordenadaYDoCentro,
    float raioDaCircunferencia
) {
    // DiferenÃ§a horizontal entre ponto e centro
    float diferencaXEntrePontoECentro = coordenadaXDoPonto - coordenadaXDoCentro;

    // DiferenÃ§a vertical entre ponto e centro
    float diferencaYEntrePontoECentro = coordenadaYDoPonto - coordenadaYDoCentro;

    // Calcula a distÃ¢ncia euclidiana entre ponto e centro:
    // âˆš[(x âˆ’ centroX)Â² + (y âˆ’ centroY)Â²]
    float distanciaEntrePontoECentro = calcularRaizQuadrada(
        diferencaXEntrePontoECentro * diferencaXEntrePontoECentro +
        diferencaYEntrePontoECentro * diferencaYEntrePontoECentro
    );

    // Verifica se a diferenÃ§a entre a distÃ¢ncia e o raio Ã© suficientemente pequena
    return calcularValorAbsoluto(distanciaEntrePontoECentro - raioDaCircunferencia) < 0.0001;
}

int main() {
    // DefiniÃ§Ã£o da circunferÃªncia
    float coordenadaXDoCentro = 0;
    float coordenadaYDoCentro = 0;
    float raioDaCircunferencia = 5;

    // Ponto a ser verificado
    float coordenadaXDoPonto = 3;
    float coordenadaYDoPonto = 4;

    // VerificaÃ§Ã£o
    if (pontoEstaSobreCircunferencia(
        coordenadaXDoPonto,
        coordenadaYDoPonto,
        coordenadaXDoCentro,
        coordenadaYDoCentro,
        raioDaCircunferencia
    )) {
        cout << "O ponto pertence Ã  circunferÃªncia." << endl;
    } else {
        cout << "O ponto NÃƒO pertence Ã  circunferÃªncia." << endl;
    }

    return 0;
}
```

---

## ğŸ’« AplicaÃ§Ãµes CÃ³smicas

* Modelagem de Ã³rbitas circulares
* SimulaÃ§Ã£o de escudos energÃ©ticos
* Radares com alcance radial

> *Na nave Exodus, as circunferÃªncias sÃ£o campos de contenÃ§Ã£o â€” Ã¡reas de harmonia onde forÃ§as opostas se equilibram.*

---

## ğŸ“Š AplicaÃ§Ãµes no Mercado Financeiro

* RepresentaÃ§Ã£o de zonas de equilÃ­brio em grÃ¡ficos de volatilidade
* SimulaÃ§Ãµes estatÃ­sticas com distribuiÃ§Ãµes circulares

> *O mercado tambÃ©m gira. E a circunferÃªncia revela onde o preÃ§o encontra simetria.*

---
